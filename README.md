<a name="custom_anchor_name"></a>

# job API :briefcase:

## Concepts applied but not limited too

- ### node js
- ### express router
- ### routes and controllers
- ### rest API
- ### mongodb atlas
- ### nosql
- ### mongoose
- ### schema & model
- ### heroku hosting
- ### jwt auth
- ### swagger ui

---

### _goals_

- combine auth knowledge with crud functionality and as a result, we'll have an api where users can log in manage there job search
- deploy app to heroku, host apps on the cloud
- setup documentation with swagger ui

---

### _notes_

- setup controllers, the functions for our routes
- setup routers, for jobs and auth with correct http methods
- connect to mongo db database
- create a user model
  - name, email, password
  - match: RegExp, creates a validator that checks if the value matches the given RegExp
  - unique: true. creates a unique index
    - if you try to save a user, but there is already a email in use, duplicate error message will be shown
- setup register router in auth controller
  - validate if user provided correct values using mongoose else send back nice error response
  - hash password
    - just in case someone breaks into database
    - never store user passwords as strings
    - hashing them generates random bites and combines them with password
    - hashing cannot be reversed, really good for storing passwords
    - library bcryptjs
      - require in controllers
      - generate salt, generate random bites > bcrypt.genSalt(10)
        - 10, how many random bites to get, bigger the number the more random bites, more secure
        - more rounds also means more processing power
      - bcrypt.hash(password, salt)
    - use mongoose pre save middleware for cleaner code
  - create token that will be associated with that user
    - jwt secret is better if generated by using key generator website
    - encryption key, 256bit
    - setup in env
  - send response with token
    - instead of all user info, really multiple setups
    - depends on how the frontend is setup
    - it may require a name property to be sent back, or frontend may decrypt the token and get it from there
    - schema instance method
      - every doc we create, we can have functions on them, instances of our schema
      - once the user is created in register, that user will have a function
      - so we'll create a function that generates that token
      - cleaner controller as a result
  - with that token user can create resources and future and make requests successfully
- login functionality
  - check wether we are getting email and password with some kind of values, because that is the whole setup for logging in
    - if not then bad request
  - check for user in our database, with UserModel.findOne()
    - if we find one then we send back user and token
    - if not then we send back another error
  - since we are using library to hash password we want to compare it as well
    - bcrypt compare, compares hashed password
    - then send back token, because suer has successfully logged in
    - set up in instances instead of jamming everything in controller
- auth middleware
  - where we can verify token, if correct, pass userId to pass along job routes
  - that way, jobs routes are protected to unique valid user
  - so, you will only deal with resources associated with that user
- job model
  - for created by, we are now tying job model with user model
  - every time we create a job, we will assign it to one of the users
  - timestamps true
    - a mongoose schema timestamp option, that tells mongoose to automatically manage created at and updated at properties on documents, so no manual setup
- job controller
  - create job
    - check to see if correct info is being sent to the controller
    - import model, create new doc on mongodb
    - now jobs will be tied to specific user
  - get all jobs
    - not all jobs, just user's jobs
  - get single job
    - check for both jobId and userId, otherwise id can be used to bring in other users info,
    - with userID coming from token, it makes it secure
  - update job
  - delete job
- set dynamic token in thunder client, using test tab
- errors
  - make errors catching more explicit
  - if an error is one of the classes we created than we pass that through
  - if not, we create a new custom error object and pass that through instead
  - Object.keys = gives us array of keys
  - we don't need custom api error now
  - validation errors
  - Cast error
- hosting on heroku (render because its free)
  - how we can protect our api
    - with help of npm packages and adding to middlewares
    - helmet
      - sets various http headers, preventing numerous possible attacks
    - cors
      - makes api accessible from different domain, if not then you will only be able to access api from same domain
      - cross origin resource sharing
      - a mechanism to allow or restrict requested resources on web server depending on where the http request was initiated
      - by using this package we make our api accessible to the public
    - xss-clean
      - a library that sanitizes user inputs in req body, query, and params
      - a result protects us from cross site scripting attacks, where the attacker tries to inject malicious code
    - express rate limit
      - limit the amount of request the user can make
      - read their docs for more info
      - if pushed to heroku, use app.set('trust proxy')
- render
  - easy to use
  - push app to github then render will use it
  - limits on free plan
    - projects will be shutdown after 15 mins of inactivity
    - which can cause delay of up to 30secs for that first request, for project to star up again
    - 750 hours of run time per month, more projects you add the faster you get to that number
    - bandwidth excess of 100gb is charged at .10/gb

[Back to Top](#custom_anchor_name)
